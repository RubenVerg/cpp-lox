#include "compiler.h"

std::unordered_map<TokenType, ParseRule> Compiler::rules{
	{TokenType::LeftParen,    ParseRule(&Compiler::grouping, nullptr,            Precedence::None)},
	{TokenType::RightParen,   ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::LeftBrace,    ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::RightBrace,   ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Comma,        ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Dot,          ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Minus,        ParseRule(&Compiler::unary,    &Compiler::binary,  Precedence::Sum)},
	{TokenType::Plus,         ParseRule(nullptr,             &Compiler::binary,  Precedence::Sum)},
	{TokenType::Slash,        ParseRule(nullptr,             &Compiler::binary,  Precedence::Product)},
	{TokenType::Star,         ParseRule(nullptr,             &Compiler::binary,  Precedence::Product)},
	{TokenType::Semicolon,    ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Bang,         ParseRule(&Compiler::unary,    nullptr,            Precedence::None)},
	{TokenType::BangEqual,    ParseRule(nullptr,             &Compiler::binary,  Precedence::Equality)},
	{TokenType::Equal,        ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::EqualEqual,   ParseRule(nullptr,             &Compiler::binary,  Precedence::Equality)},
	{TokenType::Greater,      ParseRule(nullptr,             &Compiler::binary,  Precedence::Comparison)},
	{TokenType::GreaterEqual, ParseRule(nullptr,             &Compiler::binary,  Precedence::Comparison)},
	{TokenType::Less,         ParseRule(nullptr,             &Compiler::binary,  Precedence::Comparison)},
	{TokenType::LessEqual,    ParseRule(nullptr,             &Compiler::binary,  Precedence::Comparison)},
	{TokenType::Identifier,   ParseRule(&Compiler::variable, nullptr,            Precedence::None)},
	{TokenType::String,       ParseRule(&Compiler::string,   nullptr,            Precedence::None)},
	{TokenType::Number,       ParseRule(&Compiler::number,   nullptr,            Precedence::None)},
	{TokenType::And,          ParseRule(nullptr,             &Compiler::andExpr, Precedence::And)},
	{TokenType::Or,           ParseRule(nullptr,             &Compiler::orExpr,  Precedence::Or)},
	{TokenType::Class,        ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::If,           ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Else,         ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::For,          ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::While,        ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Fun,          ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::False,        ParseRule(&Compiler::literal,  nullptr,            Precedence::None)},
	{TokenType::True,         ParseRule(&Compiler::literal,  nullptr,            Precedence::None)},
	{TokenType::Nil,          ParseRule(&Compiler::literal,  nullptr,            Precedence::None)},
	{TokenType::Print,        ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Return,       ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::This,         ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Super,        ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Var,          ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::Error,        ParseRule(nullptr,             nullptr,            Precedence::None)},
	{TokenType::EOF,          ParseRule(nullptr,             nullptr,            Precedence::None)},
};

ParseRule Compiler::rule(TokenType type) {
	return rules.at(type);
}
